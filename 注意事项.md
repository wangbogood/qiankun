# 导航跳转不可以用a标签 因为不会触发pushState无法劫持
# 为什么 <a> 标签不行及替代方案
## 为什么 <a> 标签不行
原始的 <a> 标签在点击时会直接触发浏览器的默认导航行为，这会导致：

1. 1.
   页面完全刷新 ：浏览器会向服务器发送新的请求，加载新的页面
2. 2.
   不会触发 pushState ：我们重写的 window.history.pushState 方法只在通过 JavaScript 显式调用时才会被触发
3. 3.
   路由拦截失效 ：由于没有走 pushState 方法，我们的路由劫持逻辑无法捕获到这个导航行为

   #还有一种复杂的方式 仅供参考
   // ... existing code ...
function patchRouter() {
  alert(66)
  const originalPush = window.history.pushState;
  const originalReplace = window.history.replaceState;

  // 重写 pushState 方法
  window.history.pushState = function (...args) {
    alert(1)
    const result = originalPush.apply(this, args);
    reroute();
    return result;
  };

  // 重写 replaceState 方法
  window.history.replaceState = function (...args) {
    alert(2)
    const result = originalReplace.apply(this, args);
    reroute();
    return result;
  };

  // 使用事件委托拦截导航元素点击
  document.addEventListener('click', function(e) {
    // 检查是否是我们自定义的导航元素（例如带有 data-nav 属性的元素）
    const target = e.target.closest('[data-nav]');
    if (target) {
      e.preventDefault();
      const path = target.getAttribute('data-nav');
      window.history.pushState(null, '', path);
    }
  });
}
// ... existing code ...


这个实现具有以下特点，更接近 qiankun 的核心技术：

1. 1.
   无 iframe 隔离 ：使用基于 Proxy 的 JS 沙箱实现隔离，而不是 iframe
2. 2.
   样式隔离 ：通过为 CSS 选择器添加子应用前缀实现样式隔离
3. 3.
   路由劫持 ：重写 pushState、replaceState 方法并监听 popstate 事件
4. 4.
   资源加载 ：手动加载子应用的 HTML、CSS 和 JS 资源
5. 5.
   沙箱机制 ：使用 Proxy 代理 window 对象，实现全局变量隔离
6. 6.
   全局状态管理 ：提供简单的全局状态通信 API
使用说明：

1. 1.
   子应用需要暴露 mount 和 unmount 方法
2. 2.
   子应用可以通过 window. MICRO_APP_ENVIRONMENT 判断是否在微前端环境中
3. 3.
   使用 navigateTo 函数进行路由切换
4. 4.
   启动前确保所有子应用已注册